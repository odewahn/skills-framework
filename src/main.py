import argparse
import os
import glob
import shutil
import logging
from rich.logging import RichHandler
from jinja2 import Template
import sys


NO_CHATGPT_MSG = "NOT YET GENERATED BY CHATGPT"

# Paths and directories
BLUEPRINT_PATH = "blueprint-templates"
WORK_PATH = "../work"
BLUEPRINT_DESTINATION_PATH = "blueprints"

# File extensions
JINJA_EXTENSION = ".jinja"
MARKDOWN_EXTENSION = ".md"

# README filenames
README_TEMPLATE_NAME = "README.jinja"
README_GENERATED_NAME = "README-generated.md"

# Artifact identifiers
SKILL_FRAMEWORK = "skill-framework"
SKILL_VERIFIER = "skill-verifier"
PRACTICE_QUESTIONS = "practice-questions"
LAB_ENVIRONMENT = "lab-environment"
PREP_GUIDE = "prep-guide"

BLUEPRINTS = [
    SKILL_FRAMEWORK,
    SKILL_VERIFIER,
    PRACTICE_QUESTIONS,
    LAB_ENVIRONMENT,
    PREP_GUIDE,
]

# configure rich-powered logging
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    handlers=[RichHandler(rich_tracebacks=True)],
)
logger = logging.getLogger("skills-framework")


# Create an argument parser that can accept a topic as a command-line argument
# set up top-level parser with subcommands
parser = argparse.ArgumentParser(description="A simple skills framework.")
subparsers = parser.add_subparsers(dest="command", required=True)

# 'render' command: render an blueprint for a topic
render_parser = subparsers.add_parser("render", help="Render an blueprint for a topic")
render_parser.add_argument(
    "slug",
    type=str,
    help="Topic slug (used for directories and file names)",
)
render_parser.add_argument(
    "--topic",
    dest="display_topic",
    type=str,
    required=True,
    help="Human-friendly topic name (used in templates)",
)
render_parser.add_argument(
    "blueprint",
    type=str,
    help="Artifact to create",
    choices=BLUEPRINTS,
)
render_parser.add_argument(
    "--mcp_context",
    type=str,
    help="Path to the MCP tools function file",
    default=None,
)

# 'init' command: initialize the workspace for a topic slug
init_parser = subparsers.add_parser(
    "init",
    help="Initialize a new skills-framework workspace for a topic slug",
)
init_parser.add_argument(
    "slug",
    type=str,
    help="Topic slug (used for directories and file names)",
)
init_parser.add_argument(
    "--force",
    action="store_true",
    help="Force re-initialization even if files exist",
)

# 'docs' command: generate {README_GENERATED_NAME} by injecting blueprint templates into {README_TEMPLATE_NAME}.
docs_parser = subparsers.add_parser(
    "docs",
    help=f"Generate {README_GENERATED_NAME} with reference templates injected",
)

args = parser.parse_args()


def load_file(file_path, err_msg=None):
    logger.info(f"Reading file from {file_path}")
    try:
        with open(file_path, "r") as file:
            return file.read()
    except FileNotFoundError:
        logger.error(f"Required file not found: {file_path}")
        if err_msg:
            logger.error(err_msg)
        sys.exit(0)


def generate_docs():
    f"""Generate {README_GENERATED_NAME} by injecting the blueprint templates into {README_TEMPLATE_NAME}."""
    # Load the README as a Jinja template
    readme_path = os.path.join(os.pardir, README_TEMPLATE_NAME)
    readme_tpl = load_file(
        readme_path,
        err_msg=f"{README_TEMPLATE_NAME} not found.",
    )

    # Collect blueprint template contents keyed by slugified filename
    context = {}
    for jinja_path in glob.glob(os.path.join(BLUEPRINT_PATH, f"*{JINJA_EXTENSION}")):
        name = os.path.splitext(os.path.basename(jinja_path))[0]
        varname = name.replace("-", "_")
        context[varname] = load_file(jinja_path)

    # Render and write out
    rendered = render_template(readme_tpl, context)
    output_path = os.path.join(os.pardir, README_GENERATED_NAME)
    write_file(output_path, rendered)
    logger.info(f"Generated documentation written to {output_path}")


def write_file(file_path, content):
    logger.info(f"Writing file to {file_path}")
    with open(file_path, "w") as file:
        file.write(content)


def render_template(template_str, context):
    template = Template(template_str)
    return template.render(context)


def create_blueprint(slug, blueprint, display_topic, metadata=None):
    """Render a Jinja template for the blueprint and write the generator + result files."""
    metadata = metadata or {}
    logger.info(f"Preparing {blueprint} for topic '{display_topic}'")
    topic_slug = slug

    base_dir = os.path.join(WORK_PATH, topic_slug)
    generators_dir = os.path.join(base_dir, BLUEPRINT_DESTINATION_PATH)
    os.makedirs(generators_dir, exist_ok=True)

    blueprint_template = load_file(
        os.path.join(BLUEPRINT_PATH, blueprint + JINJA_EXTENSION)
    )
    rendered_output = render_template(
        blueprint_template,
        {"topic": display_topic, **metadata},
    )

    prompt_path = os.path.join(generators_dir, blueprint + MARKDOWN_EXTENSION)
    write_file(prompt_path, rendered_output)

    result_path = os.path.join(base_dir, blueprint + MARKDOWN_EXTENSION)
    write_file(
        result_path,
        f"{NO_CHATGPT_MSG}\n\n"
        f"Paste {blueprint}{MARKDOWN_EXTENSION} from chat.openai.com output and EDIT OUT ANY CRUFT",
    )

    logger.info(f"{blueprint} generator written to {prompt_path}")
    logger.info(f"Paste {prompt_path} into chat.openai.com to generate content")
    logger.info(f"Paste output into {result_path}")


def check_chatgpt_complete(content, err_msg="An error occurred"):
    """Abort if the content marker indicates ChatGPT output is missing."""
    if content.startswith(NO_CHATGPT_MSG):
        logger.error(err_msg)
        sys.exit(1)


def init_workspace(slug, force=False):
    """Initialize a new skills-framework workspace for the given slug."""
    topic_slug = slug
    base_dir = os.path.join(WORK_PATH, topic_slug)
    generators_dir = os.path.join(base_dir, BLUEPRINT_DESTINATION_PATH)

    if os.path.exists(base_dir):
        if force:
            shutil.rmtree(base_dir)
            logger.info(f"Removed existing directory {base_dir}")
        else:
            logger.warning(
                f"Directory {base_dir} already exists; use --force to re-initialize."
            )
            return

    os.makedirs(generators_dir, exist_ok=True)
    logger.info(f"Created workspace structure under {base_dir}")


def main():
    # Dispatch subcommands
    if args.command == "init":
        init_workspace(
            slug=args.slug,
            force=args.force,
        )
        return

    if args.command == "docs":
        generate_docs()
        return

    if args.command == "render":
        slug = args.slug
        display_topic = args.display_topic

        base_dir = os.path.join(WORK_PATH, slug)
        generators_dir = os.path.join(base_dir, BLUEPRINT_DESTINATION_PATH)

        # Skill Framework is the first blueprint and does not require prior ChatGPT output
        if args.blueprint == SKILL_FRAMEWORK:
            create_blueprint(slug, args.blueprint, display_topic)
            sys.exit(1)

        skill_fw_path = os.path.join(
            base_dir,
            BLUEPRINT_DESTINATION_PATH,
            SKILL_FRAMEWORK + MARKDOWN_EXTENSION,
        )
        skill_framework = load_file(
            skill_fw_path,
            err_msg=(
                f"{SKILL_FRAMEWORK} for topic '{display_topic}' not found. "
                f"Please run init and render {SKILL_FRAMEWORK} first."
            ),
        )
        check_chatgpt_complete(
            skill_framework,
            err_msg=(
                f"ERROR: Paste {os.path.join(generators_dir, SKILL_FRAMEWORK + MARKDOWN_EXTENSION)} "
                f"into chat.openai.com and copy the results to {skill_fw_path}."
            ),
        )

        mcp_context = None
        if args.mcp_context:
            mcp_context = load_file(
                args.mcp_context,
                err_msg=(f"MCP tools function file '{args.mcp_context}' not found."),
            )
        else:
            logger.warning(
                "No MCP tools function file provided; proceeding without MCP context."
            )

        create_blueprint(
            slug,
            args.blueprint,
            display_topic,
            {"skill_framework": skill_framework, "mcp_context": mcp_context},
        )


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.warning("Process interrupted by user. Exiting...")
        sys.exit(0)
    except Exception:
        logger.exception("An unexpected error occurred:")
        sys.exit(1)
