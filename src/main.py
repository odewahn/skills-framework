import argparse
import os
import glob
import shutil
import logging
from rich.logging import RichHandler
from jinja2 import Template
import sys


NO_CHATGPT_MSG = "NOT YET GENERATED BY CHATGPT"
ARTIFACT_PATH = "artifacts"
WORK_PATH = "../work"

ARTIFACTS = [
    "skill-framework",
    "skill-framework-lite",
    "knowledge-check",
    "lab-environment",
    "skill-framework-verifier",
    "preparation-instructor",
]

# configure rich-powered logging
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    handlers=[RichHandler(rich_tracebacks=True)],
)
logger = logging.getLogger("skills-framework")


# Create an argument parser that can accept a topic as a command-line argument
# set up top-level parser with subcommands
parser = argparse.ArgumentParser(description="A simple skills framework.")
subparsers = parser.add_subparsers(dest="command", required=True)

# 'render' command: render an artifact for a topic
render_parser = subparsers.add_parser("render", help="Render an artifact for a topic")
render_parser.add_argument(
    "slug",
    type=str,
    help="Topic slug (used for directories and file names)",
)
render_parser.add_argument(
    "--topic",
    dest="display_topic",
    type=str,
    required=True,
    help="Human-friendly topic name (used in templates)",
)
render_parser.add_argument(
    "artifact",
    type=str,
    help="Artifact to create",
    choices=ARTIFACTS,
)
render_parser.add_argument(
    "--mcp_context",
    type=str,
    help="Path to the MCP tools function file",
    default=None,
)

# 'init' command: initialize the workspace for a topic slug
init_parser = subparsers.add_parser(
    "init",
    help="Initialize a new skills-framework workspace for a topic slug",
)
init_parser.add_argument(
    "slug",
    type=str,
    help="Topic slug (used for directories and file names)",
)
init_parser.add_argument(
    "--force",
    action="store_true",
    help="Force re-initialization even if files exist",
)

# 'docs' command: generate README-generated.md by injecting artifact templates into README.md
docs_parser = subparsers.add_parser(
    "docs",
    help="Generate README-generated.md with reference templates injected",
)

args = parser.parse_args()


def load_file(file_path, err_msg=None):
    logger.info(f"Reading file from {file_path}")
    try:
        with open(file_path, "r") as file:
            return file.read()
    except FileNotFoundError:
        logger.error(f"Required file not found: {file_path}")
        if err_msg:
            logger.error(err_msg)
        sys.exit(0)


def generate_docs():
    """Generate README-generated.md by injecting the artifact templates into README.md."""
    # Load the README as a Jinja template
    readme_path = os.path.join(os.pardir, "README.md")
    readme_tpl = load_file(readme_path, err_msg="README.md not found.")

    # Collect artifact template contents keyed by slugified filename
    context = {}
    for jinja_path in glob.glob(f"{ARTIFACT_PATH}/*.jinja"):
        name = os.path.splitext(os.path.basename(jinja_path))[0]
        varname = name.replace("-", "_")
        context[varname] = load_file(jinja_path)

    # Render and write out
    rendered = render_template(readme_tpl, context)
    output_path = os.path.join(os.pardir, "README-generated.md")
    write_file(output_path, rendered)
    logger.info(f"Generated documentation written to {output_path}")


def write_file(file_path, content):
    logger.info(f"Writing file to {file_path}")
    with open(file_path, "w") as file:
        file.write(content)


def render_template(template_str, context):
    template = Template(template_str)
    return template.render(context)


def create_artifact(slug, artifact, display_topic, metadata=None):
    """Render a Jinja template for the artifact and write the generator + result files."""
    metadata = metadata or {}
    logger.info(f"Preparing {artifact} for topic '{display_topic}'")
    topic_slug = slug

    base_dir = os.path.join(WORK_PATH, topic_slug)
    generators_dir = os.path.join(base_dir, "generators")
    os.makedirs(generators_dir, exist_ok=True)

    artifact_template = load_file(f"{ARTIFACT_PATH}/{artifact}.jinja")
    rendered_output = render_template(
        artifact_template,
        {"topic": display_topic, **metadata},
    )

    prompt_path = os.path.join(generators_dir, f"{artifact}.md")
    write_file(prompt_path, rendered_output)

    result_path = os.path.join(base_dir, f"{artifact}.md")
    write_file(
        result_path,
        f"{NO_CHATGPT_MSG}\n\nPaste {artifact} from chat.openai.com output and EDIT OUT ANY CRUFT",
    )

    logger.info(f"{artifact} generator written to {prompt_path}")
    logger.info(f"Paste {prompt_path} into chat.openai.com to generate content")
    logger.info(f"Paste output into {result_path}")


def check_chatgpt_complete(content, err_msg="An error occurred"):
    """Abort if the content marker indicates ChatGPT output is missing."""
    if content.startswith(NO_CHATGPT_MSG):
        logger.error(err_msg)
        sys.exit(1)


def init_workspace(slug, force=False):
    """Initialize a new skills-framework workspace for the given slug."""
    topic_slug = slug
    base_dir = os.path.join(WORK_PATH, topic_slug)
    generators_dir = os.path.join(base_dir, "generators")

    if os.path.exists(base_dir):
        if force:
            shutil.rmtree(base_dir)
            logger.info(f"Removed existing directory {base_dir}")
        else:
            logger.warning(
                f"Directory {base_dir} already exists; use --force to re-initialize."
            )
            return

    os.makedirs(generators_dir, exist_ok=True)
    logger.info(f"Created workspace structure under {base_dir}")


def main():
    # Dispatch subcommands
    if args.command == "init":
        init_workspace(
            slug=args.slug,
            force=args.force,
        )
        return

    if args.command == "docs":
        generate_docs()
        return

    if args.command == "render":
        slug = args.slug
        display_topic = args.display_topic

        base_dir = os.path.join(WORK_PATH, slug)
        generators_dir = os.path.join(base_dir, "generators")

        if args.artifact in ["skill-framework", "skill-framework-lite"]:
            create_artifact(slug, args.artifact, display_topic)
            sys.exit(1)

        skill_fw_path = os.path.join(base_dir, "generators", "skill-framework.md")
        skill_framework = load_file(
            skill_fw_path,
            err_msg=(
                f"Skill framework for topic '{display_topic}' not found. "
                "Please run init and render skill-framework first."
            ),
        )
        check_chatgpt_complete(
            skill_framework,
            err_msg=(
                f"ERROR: Paste {os.path.join(generators_dir, 'skill-framework.md')} "
                f"into chat.openai.com and copy the results to {skill_fw_path}."
            ),
        )

        mcp_context = None
        if args.mcp_context:
            mcp_context = load_file(
                args.mcp_context,
                err_msg=(f"MCP tools function file '{args.mcp_context}' not found."),
            )
        else:
            logger.warning(
                "No MCP tools function file provided; proceeding without MCP context."
            )

        create_artifact(
            slug,
            args.artifact,
            display_topic,
            {"skill_framework": skill_framework, "mcp_context": mcp_context},
        )


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.warning("Process interrupted by user. Exiting...")
        sys.exit(0)
    except Exception:
        logger.exception("An unexpected error occurred:")
        sys.exit(1)
