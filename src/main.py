import argparse
import os
import glob
import shutil
import logging
from rich.logging import RichHandler
from jinja2 import Template, StrictUndefined, UndefinedError
import sys
from pathlib import Path
import json


# Helper function to find files with a specific extension in a directory
def find_files_with_extension(directory, extension):
    """Return a list of file paths in the given directory with the specified extension."""
    return [
        Path(f).stem
        for f in os.listdir(directory)
        if f.endswith(extension) and os.path.isfile(os.path.join(directory, f))
    ]


NO_CHATGPT_MSG = "NOT YET GENERATED BY CHATGPT"

# Paths and directories
BLUEPRINT_PATH = "blueprint-templates"
WORK_PATH = "../work"
BLUEPRINT_DESTINATION_PATH = "blueprints"

# File extensions
JINJA_EXTENSION = ".jinja"
MARKDOWN_EXTENSION = ".md"

# README filenames
README_TEMPLATE_NAME = "README.jinja"
README_GENERATED_NAME = "README-generated.md"


BLUEPRINTS = find_files_with_extension(BLUEPRINT_PATH, JINJA_EXTENSION)


# configure rich-powered logging
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    handlers=[RichHandler(rich_tracebacks=True)],
)
logger = logging.getLogger("skills-framework")


# Create an argument parser that can accept a topic as a command-line argument
# set up top-level parser with subcommands
parser = argparse.ArgumentParser(description="A simple skills framework.")
subparsers = parser.add_subparsers(dest="command", required=True)

# 'render' command: render an blueprint for a topic
render_parser = subparsers.add_parser("render", help="Render an blueprint for a topic")
render_parser.add_argument(
    "slug",
    type=str,
    help="Topic slug (used for directories and file names)",
)
render_parser.add_argument(
    "blueprint",
    type=str,
    help="Artifact to create",
    choices=BLUEPRINTS,
)

# 'init' command: initialize the workspace for a topic slug
init_parser = subparsers.add_parser(
    "init",
    help="Initialize a new skills-framework workspace for a topic slug",
)
init_parser.add_argument(
    "slug",
    type=str,
    help="Topic slug (used for directories and file names)",
)
init_parser.add_argument(
    "topic",
    type=str,
    help="Human-friendly topic name (used in templates)",
)
init_parser.add_argument(
    "--force",
    action="store_true",
    help="Force re-initialization even if files exist",
)

# 'docs' command: generate {README_GENERATED_NAME} by injecting blueprint templates into {README_TEMPLATE_NAME}.
docs_parser = subparsers.add_parser(
    "docs",
    help=f"Generate {README_GENERATED_NAME} with reference templates injected",
)

# 'metadata' command: prints completed metadata for a topic slug
metadata_parser = subparsers.add_parser(
    "metadata",
    help="Print completed metadata for a topic slug",
)
metadata_parser.add_argument(
    "slug",
    type=str,
    help="Topic slug (used for directories and file names)",
)


def load_file(file_path, err_msg=None):
    logger.info(f"Reading file from {file_path}")
    try:
        with open(file_path, "r") as file:
            return file.read()
    except FileNotFoundError:
        logger.error(f"Required file not found: {file_path}")
        if err_msg:
            logger.error(err_msg)
        sys.exit(0)


def generate_docs():
    f"""Generate {README_GENERATED_NAME} by injecting the blueprint templates into {README_TEMPLATE_NAME}."""
    # Load the README as a Jinja template
    readme_path = os.path.join(os.pardir, README_TEMPLATE_NAME)
    readme_tpl = load_file(
        readme_path,
        err_msg=f"{README_TEMPLATE_NAME} not found.",
    )

    # Collect blueprint template contents keyed by slugified filename
    context = {}
    for jinja_path in glob.glob(os.path.join(BLUEPRINT_PATH, f"*{JINJA_EXTENSION}")):
        name = os.path.splitext(os.path.basename(jinja_path))[0]
        varname = name.replace("-", "_")
        context[varname] = load_file(jinja_path)

    # Render and write out
    rendered = render_template(readme_tpl, context)
    output_path = os.path.join(os.pardir, README_GENERATED_NAME)
    write_file(output_path, rendered)
    logger.info(f"Generated documentation written to {output_path}")


def write_file(file_path, content):
    logger.info(f"Writing file to {file_path}")
    with open(file_path, "w") as file:
        file.write(content)


def render_template(template_str, context):
    logger.info(f"Rendering template with context keys: {list(context.keys())}")
    template = Template(template_str, undefined=StrictUndefined)
    return template.render(context)


def load_blueprint_data(slug):
    base_dir = os.path.join(WORK_PATH, slug)
    completed_blueprints = find_files_with_extension(base_dir, MARKDOWN_EXTENSION)
    completed = {}
    for blueprint in completed_blueprints:
        path = os.path.join(base_dir, blueprint + MARKDOWN_EXTENSION)
        content = load_file(path)
        if not content.startswith(NO_CHATGPT_MSG):
            completed[blueprint] = content
        else:
            logger.error(f"{blueprint} has not been generated by ChatGPT yet.")
            logger.error(
                f"Copy the file from the {BLUEPRINT_DESTINATION_PATH} directory, paste it into chat.openai.com, and edit out any cruft."
            )
            logger.error(f"Then paste the output back into {path}.")
            return None
    # Add any json files in the base_dir to the completed dict
    json_files = find_files_with_extension(base_dir, "json")
    for json_file in json_files:
        path = os.path.join(base_dir, json_file + ".json")
        content = load_file(path)
        completed[json_file] = json.loads(content)
    return completed


def create_blueprint(slug, blueprint, metadata=None):
    """Render a Jinja template for the blueprint and write the generator + result files."""
    metadata = metadata or {}
    logger.info(f"Preparing {blueprint}")

    base_dir = os.path.join(WORK_PATH, slug)
    generators_dir = os.path.join(base_dir, BLUEPRINT_DESTINATION_PATH)
    os.makedirs(generators_dir, exist_ok=True)

    blueprint_template = load_file(
        os.path.join(BLUEPRINT_PATH, blueprint + JINJA_EXTENSION)
    )

    try:
        rendered_output = render_template(blueprint_template, metadata)

        prompt_path = os.path.join(generators_dir, blueprint + MARKDOWN_EXTENSION)
        write_file(prompt_path, rendered_output)

        result_path = os.path.join(base_dir, blueprint + MARKDOWN_EXTENSION)
        write_file(
            result_path,
            f"{NO_CHATGPT_MSG}\n\n"
            f"Paste {blueprint}{MARKDOWN_EXTENSION} from chat.openai.com output and EDIT OUT ANY CRUFT",
        )

        logger.info(f"{blueprint} generator written to {prompt_path}")
        logger.info(f"Paste {prompt_path} into chat.openai.com to generate content")
        logger.info(f"Paste output into {result_path}")
    except UndefinedError as e:
        logger.error(f"Template rendering error for {blueprint}: {e}")
        logger.error(
            f"Please ensure all required metadata in the template exists {base_dir}."
        )
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error rendering template for {blueprint}: {e}")
        sys.exit(1)


def check_chatgpt_complete(content, err_msg="An error occurred"):
    """Abort if the content marker indicates ChatGPT output is missing."""
    if content.startswith(NO_CHATGPT_MSG):
        logger.error(err_msg)
        sys.exit(1)


def init_workspace(slug, force=False):
    """Initialize a new skills-framework workspace for the given slug."""
    topic_slug = slug
    base_dir = os.path.join(WORK_PATH, topic_slug)
    generators_dir = os.path.join(base_dir, BLUEPRINT_DESTINATION_PATH)

    if os.path.exists(base_dir):
        if force:
            shutil.rmtree(base_dir)
            logger.info(f"Removed existing directory {base_dir}")
        else:
            logger.warning(
                f"Directory {base_dir} already exists; use --force to re-initialize."
            )
            return

    os.makedirs(generators_dir, exist_ok=True)
    # create a yaml file with the topic slug and display name
    metadata = {"slug": slug, "display_topic": args.topic}
    metadata_path = os.path.join(base_dir, "metadata.json")
    write_file(metadata_path, json.dumps(metadata, indent=2))
    logger.info(f"Created workspace structure under {base_dir}")


def main():
    # Dispatch subcommands
    if args.command == "init":
        init_workspace(
            slug=args.slug,
            force=args.force,
        )
        return

    if args.command == "docs":
        generate_docs()
        return

    if args.command == "metadata":
        completed = load_blueprint_data(args.slug)
        if not completed:
            logger.error(f"No completed blueprints found for topic slug '{args.slug}'.")
            sys.exit(1)
        print(json.dumps(completed, indent=2))
        return

    if args.command == "render":
        slug = args.slug
        metadata = load_blueprint_data(slug)
        create_blueprint(slug, args.blueprint, metadata)


if __name__ == "__main__":
    args = parser.parse_args()
    try:
        main()
    except KeyboardInterrupt:
        logger.warning("Process interrupted by user. Exiting...")
        sys.exit(0)
    except Exception:
        logger.exception("An unexpected error occurred:")
        sys.exit(1)
